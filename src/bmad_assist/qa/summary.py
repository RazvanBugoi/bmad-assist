"""QA summary generator using helper LLM.

Generates human-readable markdown summaries from QA execution results.
Uses helper model (haiku) for interpretation - no tool calls needed.
"""

from __future__ import annotations

import logging
from pathlib import Path

from bmad_assist.core.config import Config
from bmad_assist.providers import get_provider

logger = logging.getLogger(__name__)

# Summary generation prompt template
# Based on Step 8 from qa-plan-execute workflow
SUMMARY_PROMPT = """Generate a markdown summary report from the test execution results below.

<test-results>
{yaml_content}
</test-results>

## Output Format

Generate a markdown summary following this structure:

```markdown
# QA Execution Summary - Epic {{epic}}

**Run ID:** {{run_id}}
**Date:** {{date}}
**Duration:** {{duration}}

---

## Results Overview

| Status | Count | Percentage |
|--------|-------|------------|
| ✓ PASS | X | X% |
| ✗ FAIL | X | X% |
| ○ SKIP | X | X% |
| ⚠ ERROR | X | X% |
| **Total** | **X** | **100%** |

## Pass Rate: X%

---

## Retry Summary (if applicable)

If the results contain retry history (tests with `retries` array), add this section:

| Test ID | Original Status | Current Status | Attempts |
|---------|-----------------|----------------|----------|
| E17-A03 | FAIL | PASS | 2 |

**Improvement:** X tests fixed, pass rate improved from X% → Y%

---

## Test Results

### ✓ Passed Tests (X)
- ✓ **E{{epic}}-A01**: Test name (123ms)
- ...

### ✗ Failed Tests (X)
For each failure include:
#### E{{epic}}-A03: Test Name
- **Exit Code:** X
- **Duration:** Xms
- **Error:** {{error message}}

### ○ Skipped Tests (X)
- ○ **E{{epic}}-A10**: Test name - Reason if available

### ⚠ Error Tests (X)
- ⚠ **E{{epic}}-A15**: Test name - Error if available

---

## Recommendations

Based on failure patterns, suggest:
- If CLI failures: "Check if virtual environment is activated"
- If permission errors: "Verify file permissions"
- If timeouts: "Consider increasing timeout"
- If import errors: "Ensure dependencies are installed"

---

*Generated by bmad-assist QA summary generator*
```

## Instructions

1. Calculate all statistics from the YAML data
2. Include the Retry Summary section ONLY if any test has a `retries` array
3. For retry summary, calculate improvement metrics (before vs after pass rates)
4. List all tests in appropriate sections based on current status
5. Generate actionable recommendations based on failure patterns
6. Output ONLY the markdown summary, no explanations or preamble

Generate the summary now:
"""


def generate_summary(
    results_path: Path,
    config: Config,
) -> Path | None:
    """Generate summary markdown using helper LLM.

    Reads the YAML results file, sends to helper LLM for interpretation,
    and writes the summary markdown file.

    Args:
        results_path: Path to the YAML results file.
        config: Configuration instance.

    Returns:
        Path to generated summary file, or None if generation failed.

    """
    if not results_path.exists():
        logger.error("Results file not found: %s", results_path)
        return None

    # Load YAML content
    try:
        with open(results_path, encoding="utf-8") as f:
            yaml_content = f.read()
    except Exception as e:
        logger.error("Failed to read results file %s: %s", results_path, e)
        return None

    # Build prompt
    prompt = SUMMARY_PROMPT.format(yaml_content=yaml_content)

    logger.info("Generating summary for %s using helper LLM...", results_path.name)

    # Use helper provider config
    provider_name = config.providers.helper.provider
    model_name = config.providers.helper.model

    provider = get_provider(provider_name)

    # Invoke helper LLM (no tools needed - pure text generation)
    result = provider.invoke(
        prompt,
        model=model_name,
        timeout=60,  # Short timeout for summary generation
        disable_tools=True,  # No tools needed for text generation
        env_file=config.providers.helper.env_file_path,
        env_overrides=dict(config.providers.helper.env_overrides),
    )

    if result.exit_code != 0:
        error_msg = result.stderr[:200] if result.stderr else "Unknown error"
        logger.error("Summary generation failed: %s", error_msg)
        return None

    # Extract markdown from output
    summary_content = _extract_markdown(result.stdout)

    if not summary_content:
        logger.error("No summary content generated")
        return None

    # Write summary file (same basename as YAML but with -summary.md)
    summary_path = results_path.with_suffix("").with_suffix("").parent / (
        results_path.stem + "-summary.md"
    )

    try:
        summary_path.parent.mkdir(parents=True, exist_ok=True)
        with open(summary_path, "w", encoding="utf-8") as f:
            f.write(summary_content)
        logger.info("Summary written to: %s", summary_path)
        return summary_path
    except Exception as e:
        logger.error("Failed to write summary file: %s", e)
        return None


def _extract_markdown(output: str) -> str:
    """Extract markdown content from LLM output.

    Handles cases where LLM might wrap markdown in code blocks or
    add explanatory text before/after. Also handles duplicate content.

    Args:
        output: Raw LLM output.

    Returns:
        Cleaned markdown content.

    """
    content = output.strip()

    # If wrapped in markdown code block, extract it
    if content.startswith("```markdown"):
        # Find END of first code block (not last, in case of duplicates)
        end_idx = content.find("\n```", 13)  # Skip past "```markdown\n"
        if end_idx > 15:  # len("```markdown\n")
            content = content[13:end_idx].strip()
    elif content.startswith("```md"):
        end_idx = content.find("\n```", 6)
        if end_idx > 6:
            content = content[6:end_idx].strip()
    elif content.startswith("```"):
        # Generic code block
        first_newline = content.find("\n")
        end_idx = content.find("\n```", first_newline + 1)
        if end_idx > first_newline > 0:
            content = content[first_newline + 1 : end_idx].strip()

    # If starts with # (markdown header), it's probably clean
    if content.startswith("#"):
        return content

    # Try to find the start of the markdown (# QA Execution Summary)
    header_idx = content.find("# QA Execution Summary")
    if header_idx >= 0:
        content = content[header_idx:]

    return content


def get_summary_path(results_path: Path) -> Path:
    """Get the expected summary path for a results file.

    Args:
        results_path: Path to results YAML file.

    Returns:
        Path where summary markdown should be/is stored.

    """
    return results_path.with_suffix("").with_suffix("").parent / (results_path.stem + "-summary.md")
